---
title: "hovestadt_nature_2019_smartSeq2_QC_and_analysis"
author: "JJ"
date: "2023-03-02"
output: html_document
---

```{r graphical_output}
options(bitmapType='cairo-png') # this line of code needed BEFORE knitr code in chunk below
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = TRUE,   # prints the code (if FALSE then only code output is shown)
                      cache = TRUE,
                      fig.path = "./outputs50K/Hovestadt_outputs/figures/")
```

```{r libraries}
suppressPackageStartupMessages({
library(Seurat)
library(SeuratData)
library(SeuratWrappers)
library(batchelor)
library(cluster)
library(factoextra)
library(glmGamPoi)
library(Matrix)
library(patchwork)
library(tidyverse)
})
```


```{r eval=FALSE, echo=FALSE}
raw.counts.muv41 <- read.table(file = "./hovestadt_Nature2019/GSM3905417_MUV41.txt",
                         sep = "")
```

```{r eval=FALSE, echo=FALSE}
head(raw.counts.muv41)
```

```{r eval=FALSE, echo=FALSE}
muv41 <- CreateSeuratObject(raw.counts.muv41,
                            min.cells = 10,
                            min.genes = 2500,
                            project = "reanalysis_hovestadt")
```

```{r eval=FALSE, echo=FALSE}
dim(muv41)
```

```{r eval=FALSE, echo=FALSE}
muv41 <- SCTransform(muv41, vst.flavor = "v2", verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)
```

```{r eval=FALSE, echo=FALSE}
DimPlot(muv41, label = T, repel = T)
```

```{r eval=FALSE, echo=FALSE, fig.height=9, fig.width=12}
VlnPlot(muv41, features = c("SOX2", "POU3F2", "FABP7", "OTX2", "ZIC2", "GLI2"))
```

```{r eval=FALSE, echo=FALSE}
raw.counts.sj454 <- read.table(file = "./hovestadt_Nature2019/GSM3905423_SJ454.txt",
                         sep = "")
```

```{r eval=FALSE, echo=FALSE}
head(raw.counts.sj454)
```

```{r eval=FALSE, echo=FALSE}
sj454 <- CreateSeuratObject(raw.counts.sj454,
                            min.cells = 10,
                            min.genes = 2500,
                            project = "reanalysis_hovestadt")
```

```{r eval=FALSE, echo=FALSE}
dim(sj454)
```

```{r eval=FALSE, echo=FALSE}
sj454 <- SCTransform(sj454, vst.flavor = "v2", verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)
```

```{r eval=FALSE, echo=FALSE}
DimPlot(sj454, label = T, repel = T)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(sj454,
        file = "./outputs50K/Hovestadt_outputs/SJ454.SHH_MB.SOX2networkExpression.MitoCellsGenesFilt.RiboRetained.SCT.clustered.rds")
```

```{r}
sj454.clust <- readRDS("outputs50K/Hovestadt_outputs/SJ454.SHH_MB.SOX2networkExpression.MitoCellsGenesFilt.RiboRetained.SCT.clustered.rds")
```

```{r eval=FALSE, echo=FALSE}
VlnPlot(sj454.clust, features = c("NEUROD1"))
```


```{r VlnplotSOX2regNetworkSJ454shhMB, fig.height=17, fig.width=16}
# cluster 2 expresses all NSC factors except OTX2
# VlnPlot(sj454, features = c("SOX2", "POU3F2", "FABP7", "OTX2", "ZIC2", "GLI2", "OCT4", "PAX6"))

p1a <- VlnPlot(sj454.clust, 
        features = c("SOX2")) +
  theme(axis.text = element_text(size = 22),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 22),
        legend.position = "none",
        plot.title = element_text(size = 30))

p1b <- VlnPlot(sj454.clust, 
        features = c("POU3F2")) +
  theme(axis.text = element_text(size = 22),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 22),
        legend.position = "none",
        plot.title = element_text(size = 30))

p1c <- VlnPlot(sj454.clust, 
        features = c("FABP7")) +
  theme(axis.text = element_text(size = 22),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 22),
        legend.position = "none",
        plot.title = element_text(size = 30))

p1d <- VlnPlot(sj454.clust, 
        features = c("PAX6")) +
  theme(axis.text = element_text(size = 22),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 22),
        legend.position = "none",
        plot.title = element_text(size = 30))

p1e <- VlnPlot(sj454.clust, 
        features = c("ZIC2")) +
  theme(axis.text = element_text(size = 22),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 22),
        legend.position = "none",
        plot.title = element_text(size = 30))

p1f <- VlnPlot(sj454.clust, 
        features = c("GLI2")) +
  theme(axis.text = element_text(size = 22),
        axis.title.x = element_blank(),
        axis.title.y = element_text(size = 22),
        legend.position = "none",
        plot.title = element_text(size = 30))

p1a + p1b + p1c + p1d + p1e + p1f + plot_layout(ncol = 2)
```

```{r eval=FALSE, echo=FALSE}
raw.counts.sj577 <- read.table(file = "./hovestadt_Nature2019/GSM3905425_SJ577.txt",
                         sep = "")
```

```{r eval=FALSE, echo=FALSE}
head(raw.counts.sj577)
```

```{r eval=FALSE, echo=FALSE}
sj577 <- CreateSeuratObject(raw.counts.sj577,
                            min.cells = 10,
                            min.genes = 2500,
                            project = "reanalysis_hovestadt")
```

```{r eval=FALSE, echo=FALSE}
dim(sj577)
```

```{r eval=FALSE, echo=FALSE}
sj577 <- SCTransform(sj577, vst.flavor = "v2", verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)
```

```{r eval=FALSE, echo=FALSE}
DimPlot(sj577, label = T, repel = T)
```

```{r eval=FALSE, echo=FALSE}
VlnPlot(sj577, features = c("SOX2", "POU3F2", "FABP7", "OTX2", "ZIC2", "GLI2"))
```



------------------------------------------------------------------------------------------------------
***Integrate WNT-MB, SHH-MB, DAOY-SPHEROID, DAOY-only coculture using fastMNN***

Prepare the non SHH-MB patient tumour samples for integration with the datasets in the TSNE plot above
-test: integrate 2 WNT tumours with 2 Gp 3 tumours
```{r eval=FALSE, echo=FALSE}
# identify the files of interest
list.files('hovestadt_Nature2019')
```

```{r eval=FALSE, echo=FALSE}
# merge the 3 WNT-MB and 3 SHH-MB datasets
# load the data
# 3 WNT-MB
raw.counts.sj516 <- read.table(file = "./hovestadt_Nature2019/GSM3905424_SJ516.txt",
                         sep = "")
raw.counts.bch807 <- read.table(file = "./hovestadt_Nature2019/GSM3905406_BCH807.txt",
                         sep = "")
raw.counts.sj129 <- read.table(file = "./hovestadt_Nature2019/GSM3905421_SJ129.txt",
                         sep = "")
# 3 SHH-MB
raw.counts.muv41 <- read.table(file = "./hovestadt_Nature2019/GSM3905417_MUV41.txt",
                         sep = "")
raw.counts.sj454 <- read.table(file = "./hovestadt_Nature2019/GSM3905423_SJ454.txt",
                         sep = "")
raw.counts.sj577 <- read.table(file = "./hovestadt_Nature2019/GSM3905425_SJ577.txt",
                         sep = "")


# create Seurat objects for tumours
sj516.wnt <- CreateSeuratObject(raw.counts.sj516,
                            min.cells = 10,
                            min.genes = 200,
                            project = "wntA")
bch807.wnt <- CreateSeuratObject(raw.counts.bch807,
                            min.cells = 10,
                            min.genes = 200,
                            project = "wntB")
sj129.wnt <- CreateSeuratObject(raw.counts.sj129,
                            min.cells = 10,
                            min.genes = 200,
                            project = "wntC")

muv41.shh <- CreateSeuratObject(raw.counts.muv41,
                            min.cells = 10,
                            min.genes = 200,
                            project = "shhA")
sj454.shh <- CreateSeuratObject(raw.counts.sj454,
                            min.cells = 10,
                            min.genes = 200,
                            project = "shhB")
sj577.shh <- CreateSeuratObject(raw.counts.sj577,
                            min.cells = 10,
                            min.genes = 200,
                            project = "shhC")

# load the DAOY spheroid data
dySpher <- readRDS("outputs50K/DAOY_SPHER/filt.MitoCellsGenes.RiboRetained.seurat.DAOYspher.rds")
```

```{r eval=FALSE, echo=FALSE}
hov.6tumours.dySpher.merged <- merge(sj516.wnt, 
                    y = c(bch807.wnt, sj129.wnt, muv41.shh, sj454.shh, sj577.shh, dySpher),
                    project = "hov.6tumours.dySpher.merged")
```

```{r eval=FALSE, echo=FALSE}
table(hov.6tumours.dySpher.merged@meta.data$orig.ident)
```

```{r eval=FALSE, echo=FALSE}
# scale data step is not necessary as RunFastMNN does its own scaling
hov.6tumours.dySpher.merged.clust <- NormalizeData(hov.6tumours.dySpher.merged)
hov.6tumours.dySpher.merged.clust <- FindVariableFeatures(hov.6tumours.dySpher.merged.clust)
hov.6tumours.dySpher.merged.clust <- RunFastMNN(object.list = SplitObject(hov.6tumours.dySpher.merged.clust, split.by = "orig.ident"))
hov.6tumours.dySpher.merged.clust <- RunUMAP(hov.6tumours.dySpher.merged.clust, reduction = "mnn", dims = 1:20)
hov.6tumours.dySpher.merged.clust <- FindNeighbors(hov.6tumours.dySpher.merged.clust, reduction = "mnn", dims = 1:20)
hov.6tumours.dySpher.merged.clust <- FindClusters(hov.6tumours.dySpher.merged.clust)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(hov.6tumours.dySpher.merged.clust,
        file = "./outputs50K/Hovestadt_outputs/DAOYspher.WNTMBSHHMBHov.fastMNN.clust.rds")
```

```{r}
hov.6tumours.dySpher.merged.clust <- readRDS("outputs50K/Hovestadt_outputs/DAOYspher.WNTMBSHHMBHov.fastMNN.clust.rds")
```


```{r DimplotHOV6tumoursDAOYspheroidMNN, fig.height=4, fig.width=4}
# p2a <- DimPlot(hov.6tumours.dySpher.merged.clust, group.by = c("orig.ident"), split.by = "orig.ident", pt.size = 3)
p2 <- DimPlot(hov.6tumours.dySpher.merged.clust, group.by = c("orig.ident"), pt.size = 3)
p2
```

```{r eval=FALSE, echo=FALSE}
# merge the 3 WNT-MB and 3 SHH-MB datasets with daoy-only coculture
# load the data
# 3 WNT-MB
raw.counts.sj516 <- read.table(file = "./hovestadt_Nature2019/GSM3905424_SJ516.txt",
                         sep = "")
raw.counts.bch807 <- read.table(file = "./hovestadt_Nature2019/GSM3905406_BCH807.txt",
                         sep = "")
raw.counts.sj129 <- read.table(file = "./hovestadt_Nature2019/GSM3905421_SJ129.txt",
                         sep = "")
# 3 SHH-MB
raw.counts.muv41 <- read.table(file = "./hovestadt_Nature2019/GSM3905417_MUV41.txt",
                         sep = "")
raw.counts.sj454 <- read.table(file = "./hovestadt_Nature2019/GSM3905423_SJ454.txt",
                         sep = "")
raw.counts.sj577 <- read.table(file = "./hovestadt_Nature2019/GSM3905425_SJ577.txt",
                         sep = "")


# create Seurat objects for tumours
sj516.wnt <- CreateSeuratObject(raw.counts.sj516,
                            min.cells = 10,
                            min.genes = 200,
                            project = "wntA")
bch807.wnt <- CreateSeuratObject(raw.counts.bch807,
                            min.cells = 10,
                            min.genes = 200,
                            project = "wntB")
sj129.wnt <- CreateSeuratObject(raw.counts.sj129,
                            min.cells = 10,
                            min.genes = 200,
                            project = "wntC")

muv41.shh <- CreateSeuratObject(raw.counts.muv41,
                            min.cells = 10,
                            min.genes = 200,
                            project = "shhA")
sj454.shh <- CreateSeuratObject(raw.counts.sj454,
                            min.cells = 10,
                            min.genes = 200,
                            project = "shhB")
sj577.shh <- CreateSeuratObject(raw.counts.sj577,
                            min.cells = 10,
                            min.genes = 200,
                            project = "shhC")

# load the DAOY-only cells subsetted from DAOY-CBO data
dyOnly.dyCbo <- readRDS("outputs50K/DAOY-CBO/DAOYOnlyCells.SubsetDAOYCboSample.RiboRetained.NoMito.SCT.CCdiffRegressed.rds")
```

```{r eval=FALSE, echo=FALSE}
# load the DAOY-CBO object
dyCbo <- readRDS("outputs50K/DAOY-CBO/filt.MitoCellsGenes.RiboGenesRetained.seurat.DAOYcbo.rds")
```

```{r eval=FALSE, echo=FALSE}
# get the DAOY only cells that have NOT been through SCT normalisation
dyOnlyIDs <- WhichCells(dyOnly.dyCbo)
dyOnly <- subset(dyCbo, cells = dyOnlyIDs)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(dyOnly,
        "./outputs50K/INTEGRATE/DAOYonly.DAOYcbo.NOTclustered.NoSCT.FiltMitoCellsGenes.RiboRetained.rds")
```


```{r eval=FALSE, echo=FALSE}
hov.6tumours.dyOnly.merged <- merge(sj516.wnt, 
                    y = c(bch807.wnt, sj129.wnt, muv41.shh, sj454.shh, sj577.shh, dyOnly.dyCbo),
                    project = "hov.6tumours.dyOnly.merged")
```

```{r eval=FALSE, echo=FALSE}
table(hov.6tumours.dyOnly.merged@meta.data$orig.ident)
```

```{r eval=FALSE, echo=FALSE}
# scale data step is not necessary as RunFastMNN does its own scaling
hov.6tumours.dyOnly.merged.clust <- NormalizeData(hov.6tumours.dyOnly.merged)
hov.6tumours.dyOnly.merged.clust <- FindVariableFeatures(hov.6tumours.dyOnly.merged.clust)
hov.6tumours.dyOnly.merged.clust <- RunFastMNN(object.list = SplitObject(hov.6tumours.dyOnly.merged.clust, split.by = "orig.ident"))
hov.6tumours.dyOnly.merged.clust <- RunUMAP(hov.6tumours.dyOnly.merged.clust, reduction = "mnn", dims = 1:20)
hov.6tumours.dyOnly.merged.clust <- FindNeighbors(hov.6tumours.dyOnly.merged.clust, reduction = "mnn", dims = 1:20)
hov.6tumours.dyOnly.merged.clust <- FindClusters(hov.6tumours.dyOnly.merged.clust)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(hov.6tumours.dyOnly.merged.clust,
        file = "./outputs50K/Hovestadt_outputs/DAOYonlyDAOYcbo.WNTMBSHHMBHov.fastMNN.clust.rds")
```

```{r}
hov.6tumours.dyOnly.merged.clust <- readRDS("outputs50K/Hovestadt_outputs/DAOYonlyDAOYcbo.WNTMBSHHMBHov.fastMNN.clust.rds")
```


```{r DimplotHOV6tumoursDAOYonlyDAOYcboMNN, fig.height=4, fig.width=4}
p3 <- DimPlot(hov.6tumours.dyOnly.merged.clust, group.by = c("orig.ident"), pt.size = 3)
p3
```


***Run fastMNN on DAOY-spheroid or DAOY-only coculture in comparison to SHH-MB's only before calculating Mixing Metric***

```{r eval=FALSE, echo=FALSE}
# merge daoy-spher with patient SHH-MB's only
dySpher.hovShhMB.merged <- merge(dySpher,
                                 y = c(muv41.shh, sj454.shh, sj577.shh),
                                 project = "hov.SHHMB.dySpher.merged")
dyOnly.hovShhMB.merged <- merge(dyOnly,
                                 y = c(muv41.shh, sj454.shh, sj577.shh),
                                 project = "hov.SHHMB.dyOnly.merged")
```

```{r eval=FALSE, echo=FALSE}
# scale data step is not necessary as RunFastMNN does its own scaling
dySpher.hovShhMB.merged.clust <- NormalizeData(dySpher.hovShhMB.merged)
dySpher.hovShhMB.merged.clust <- FindVariableFeatures(dySpher.hovShhMB.merged.clust)
dySpher.hovShhMB.merged.clust <- RunFastMNN(object.list = SplitObject(dySpher.hovShhMB.merged.clust, split.by = "orig.ident"))
dySpher.hovShhMB.merged.clust <- RunUMAP(dySpher.hovShhMB.merged.clust, reduction = "mnn", dims = 1:20)
dySpher.hovShhMB.merged.clust <- FindNeighbors(dySpher.hovShhMB.merged.clust, reduction = "mnn", dims = 1:20)
dySpher.hovShhMB.merged.clust <- FindClusters(dySpher.hovShhMB.merged.clust)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(dySpher.hovShhMB.merged.clust,
        file = "./outputs50K/Hovestadt_outputs/DAOYspher.SHHMBHov.fastMNN.clust.rds")
```

```{r}
dySpher.hovShhMB.merged.clust <- 
  readRDS("outputs50K/Hovestadt_outputs/DAOYspher.SHHMBHov.fastMNN.clust.rds")
```


```{r DimplotHOVSHHMBtumoursDAOYspherMNN, fig.height=4, fig.width=4}
p4 <- DimPlot(dySpher.hovShhMB.merged.clust, group.by = c("orig.ident"), pt.size = 3)
p4
```


```{r eval=FALSE, echo=FALSE}
# run fastMNN on DAOY-only cells in coculture and patient SHH-MB
# scale data step is not necessary as RunFastMNN does its own scaling
dyOnly.hovShhMB.merged.clust <- NormalizeData(dyOnly.hovShhMB.merged)
dyOnly.hovShhMB.merged.clust <- FindVariableFeatures(dyOnly.hovShhMB.merged.clust)
dyOnly.hovShhMB.merged.clust <- RunFastMNN(object.list = SplitObject(dyOnly.hovShhMB.merged.clust, split.by = "orig.ident"))
dyOnly.hovShhMB.merged.clust <- RunUMAP(dyOnly.hovShhMB.merged.clust, reduction = "mnn", dims = 1:20)
dyOnly.hovShhMB.merged.clust <- FindNeighbors(dyOnly.hovShhMB.merged.clust, reduction = "mnn", dims = 1:20)
dyOnly.hovShhMB.merged.clust <- FindClusters(dyOnly.hovShhMB.merged.clust)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(dyOnly.hovShhMB.merged.clust,
        file = "./outputs50K/Hovestadt_outputs/DAOYonlyDAOYcbo.SHHMBHov.fastMNN.clust.rds")
```

```{r}
dyOnly.hovShhMB.merged.clust <- 
  readRDS("outputs50K/Hovestadt_outputs/DAOYonlyDAOYcbo.SHHMBHov.fastMNN.clust.rds")
```


```{r DimplotHOVSHHMBtumoursDaoyOnlyCocultMNN, fig.height=6, fig.width=6}
p5 <- DimPlot(dyOnly.hovShhMB.merged.clust, group.by = c("orig.ident"), pt.size = 3)
p5
```

```{r eval=FALSE, echo=FALSE}
# only merge the three SHH-MB's
hovShhMB.merged <- merge(muv41.shh,
                        y = c(sj454.shh, sj577.shh),
                        project = "hov.SHHMB.merged")
```

```{r eval=FALSE, echo=FALSE}
# scale data step is not necessary as RunFastMNN does its own scaling
hovShhMB.merged.clust <- NormalizeData(hovShhMB.merged)
hovShhMB.merged.clust <- FindVariableFeatures(hovShhMB.merged.clust)
hovShhMB.merged.clust <- RunFastMNN(object.list = SplitObject(hovShhMB.merged.clust, split.by = "orig.ident"))
hovShhMB.merged.clust <- RunUMAP(hovShhMB.merged.clust, reduction = "mnn", dims = 1:20)
hovShhMB.merged.clust <- FindNeighbors(hovShhMB.merged.clust, reduction = "mnn", dims = 1:20)
hovShhMB.merged.clust <- FindClusters(hovShhMB.merged.clust)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(hovShhMB.merged.clust,
        file = "./outputs50K/Hovestadt_outputs/SHHMBHov.fastMNN.clust.rds")
```

```{r}
hovShhMB.merged.clust <- 
  readRDS("outputs50K/Hovestadt_outputs/SHHMBHov.fastMNN.clust.rds")
```


```{r DimplotHOVSHHMBtumoursMNN, fig.height=6, fig.width=6}
p6 <- DimPlot(hovShhMB.merged.clust, group.by = c("orig.ident"), pt.size = 3)
p6
```

```{r eval=FALSE, echo=FALSE}
# calculate mixing metric for 3 SHH-MB tumours with DAOY-SPHEROID cells
# MixingMetric is a numeric vector
max.k <- 300
dySpher.hovShhMB.merged.clust.mm <- max.k - MixingMetric(object = dySpher.hovShhMB.merged.clust, 
             grouping.var = "orig.ident",
             reduction = "umap",
             dims = 1:2,
             k = 5,
             max.k = max.k,
             eps = 0,
             verbose = TRUE)
```

```{r eval=FALSE, echo=FALSE}
# calculate mixing metric for 3 SHH-MB tumours with DAOY-only cells in DAOY-CBO coculture
# MixingMetric is a numeric vector
max.k <- 300
dyOnly.hovShhMB.merged.clust.mm <- max.k - MixingMetric(object = dyOnly.hovShhMB.merged.clust, 
             grouping.var = "orig.ident",
             reduction = "umap",
             dims = 1:2,
             k = 5,
             max.k = max.k,
             eps = 0,
             verbose = TRUE)
```

```{r}
# calculate mixing metric for 6 tumours with DAOY-SPHEROID cells
# MixingMetric is a numeric vector
max.k <- 300
hovShhMB.merged.clust.mm <- max.k - MixingMetric(object = hovShhMB.merged.clust, 
             grouping.var = "orig.ident",
             reduction = "umap",
             dims = 1:2,
             k = 5,
             max.k = max.k,
             eps = 0,
             verbose = TRUE)
```

Make a GGPLOT VIOLIN PLOT of all the MixingMetric scores for the different integrations
```{r eval=FALSE, echo=FALSE}
# check the lengths of each vector to find the longest - longest vector has  values
length(dySpher.hovShhMB.merged.clust.mm)   # spher + patient MB
length(dyOnly.hovShhMB.merged.clust.mm) # cocult-only + patient MB
length(hovShhMB.merged.clust.mm) # patient MB only
```

```{r eval=FALSE, echo=FALSE}
dyOnly.hovShhMB.merged.clust.mm.na <- c(dyOnly.hovShhMB.merged.clust.mm, rep(NA, 378))
hovShhMB.merged.clust.mm.na <- c(hovShhMB.merged.clust.mm, rep(NA, 649))
```

```{r eval=FALSE, echo=FALSE}
summary(dySpher.hovShhMB.merged.clust.mm) # spher + patient MB
summary(dyOnly.hovShhMB.merged.clust.mm.na) # cocult + patient MB
summary(hovShhMB.merged.clust.mm.na) # patient MB only
```

```{r eval=FALSE, echo=FALSE}
# create a dataframe of the MixingMetric scores for all integrations
daoy.patientShhMB.df2 <- data.frame(DAOY_coculture_patientMB = dyOnly.hovShhMB.merged.clust.mm.na,
                                   DAOY_spheroid_patientMB = dySpher.hovShhMB.merged.clust.mm,
                                   patientMB = hovShhMB.merged.clust.mm.na)

daoy.patientShhMB.df2.long <- pivot_longer(daoy.patientShhMB.df2,
                                       cols = c(DAOY_coculture_patientMB, DAOY_spheroid_patientMB, patientMB),
                                       names_to = "groups.fct",
                                       values_to = "mixing_metric")

# daoy.patientShhMB.df2.long$groups.fct <- factor(daoy.patientShhMB.df2.long$groups.fct)

levels.order <- c("patientMB", "DAOY_coculture_patientMB", "DAOY_spheroid_patientMB")

daoy.patientShhMB.df2.long$groups.fct <- factor(daoy.patientShhMB.df2.long$groups.fct,
                                            levels = levels.order)
```

```{r eval=FALSE, echo=FALSE}
saveRDS(daoy.patientShhMB.df2.long,
        file = "./outputs50K/Hovestadt_outputs/LongDataFrame.MixingMetrics.HOVpatientSHHMB.DAOYonlyCocult.DAOYspher.rds")
```

```{r}
# load the df in long format for ggplot plotting
daoy.patientShhMB.df2.long <- 
  readRDS("outputs50K/Hovestadt_outputs/LongDataFrame.MixingMetrics.HOVpatientSHHMB.DAOYonlyCocult.DAOYspher.rds")
```

```{r ViolinplotMixingMetricShhMb1PatientsDAOY, fig.height=4, fig.width=4}
# violin plot of the MixingMetric scores for all integrations
ggplot(daoy.patientShhMB.df2.long, aes(x = groups.fct, y = mixing_metric)) +
  geom_violin(scale = "width", fill = "light blue", colour = "light blue") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1, size = 20),
        axis.text.y = element_text(size = 15),
        axis.title.y = element_text(size = 20, margin = margin(r=20)),
        axis.title.x = element_blank() )
```




########################################################################################################
--------------------------------------------------------------------------------------------------------
CODE THAT WAS NOT VERY USEFUL BUT RETAINED FOR FUTURE USE


SILHOUETTE ANALYSIS:
INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH DAOY SPHEROID USING SILHOUETTE ANALYSIS

```
{r}
# load the files
shhMb1.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.spher.cocult.clustered.conventionalIntegration.rds")
shhMb1.1.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.1.combined.Hovestadt.SHH-MBpatients_n=3.DAOYspher.cocult.clustered.conventionalIntegration.rds")
shhMb1.2.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.2.combined.Hovestadt.SHH-MBpatients_n=3.DAOYcocult.clustered.conventionalIntegration.rds")
shhMb1.3.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.3.combined.Hovestadt.SHH-MBpatients_n=3.DAOYspher.clustered.conventionalIntegration.rds")
shhMb1.4.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.4.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.clustered.conventionalIntegration.rds")
shhMb1.5.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.5.combined.Hovestadt.SHH-MBpatients_n=3.NoDAOY.conventionalIntegration.rds")
```

```
{r}
DimPlot(shhMb1.4.combined, reduction = "tsne", group.by = "seurat_clusters", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

```
{r}
# Calculate Euclidean distance matrix -  GetAssayData() is used to extract the data matrix from the Seurat object, and t() is used to transpose it so that the cells are in rows and the genes are in columns, which is the format required for the dist() function.
dist.mat <- dist(t(GetAssayData(object = shhMb1.4.combined, slot = "data")))
```

```
{r}
# save the dist.mat as it takes a long time to compute - THIS FILE HAS BEEN DELETED
saveRDS(dist.mat,
        file = "./outputs50K/Hovestadt_outputs/distanceMatrix.shhMb1.4.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.clustered.conventionalIntegration.rds")
```

```
{r}
dist.mat <- readRDS("outputs50K/Hovestadt_outputs/distanceMatrix.shhMb1.4.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.clustered.conventionalIntegration.rds")
clusters <- shhMb1.4.combined@meta.data$integrated_snn_res.0.5
```

```
{r}
# Calculate silhouette scores
sil <- silhouette(x = as.numeric(x = as.factor(x = clusters)), dist = dist.mat)
```

```
{r}
shhMb1.4.combined$sil <- sil[, 3]
```

```
{r}
# median scores that are lower indicate better cell mixing, i.e. cells are more similar
summary(shhMb1.4.combined@meta.data$sil)
```




SCTransform integration did not work so well even with cell cycle regression and using the full DAOY-monolayer (DAOY-rep) or using a donsampled DAOY monolayer 

Try SCTransform as the spheroid and the daoy-only coculture overlap a lot

```
{r}
# trial of SCTransform
dyMono <- readRDS("outputs50K/DAOY_2D/filt.RiboMitoCellsGenes.seurat.DaoyMonolayer.rds")
# normalise data
dyMono <- NormalizeData(dyMono)
# calculate CC difference
dyMono <- CellCycleScoring(dyMono,
                g2m.features = cc.genes$g2m.genes,
                s.features = cc.genes$s.genes)
dyMono$CC.difference <- dyMono$S.Score - dyMono$G2M.Score
```

```
{r}

# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
dyMono.input.integration <- SCTransform(dyMono, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
dySpher.input.integration <- 
  readRDS("outputs50K/DAOY_SPHER/DAOYspher.inputIntegration.SCTransformed.CCdiffRegressed.PCA.unclustered.rds")
```

```
{r}
dyOnly.dyCbo <- 
  readRDS("outputs50K/DAOY-CBO/DAOYOnlyCells.SubsetDAOYCboSample.Annotated.Rescaled.SCT.NoRiboNoMito.CCdiffRegressed.rds")
```

As can be seen from the below, the dyOnly.dyCbo object has a prefix before the cell ID. This must be removed before proceeding
```
{r}
head(WhichCells(dyOnly.dyCbo))
```

```
{r}
# store the above cell IDs as a vector
dyOnly.cellID <- WhichCells(dyOnly.dyCbo)
```

```
{r}
# remove the prefixes from the vector cell names and save as a new object of cell IDs
dyOnly.cellID.corrected <- gsub('dyCbo.data-', '', dyOnly.cellID)
head(dyOnly.cellID.corrected) # the prefixes have been removed
```

```
{r}
# rename the cell IDs with the corrected cell names (.ccn = corrected cell names)
# the object dyOnly.dyCbo.ccn is the one to use going forwards
dyOnly.dyCbo.ccn <- RenameCells(dyOnly.dyCbo, new.names = dyOnly.cellID.corrected)
head(WhichCells(dyOnly.dyCbo.ccn))
```

```
{r}
# prepare MUV41
# normalise the object
muv41 <- NormalizeData(muv41)

# get cell cycle scores, then regress this variable out
muv41 <- CellCycleScoring(muv41,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes)
muv41$CC.difference <- muv41$S.Score - muv41$G2M.Score
```

```
{r}
# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
muv41.input.integration <- SCTransform(muv41, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
# prepare SJ454
# normalise the object
sj454 <- NormalizeData(sj454)

# get cell cycle scores, then regress this variable out
sj454 <- CellCycleScoring(sj454,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
sj454$CC.difference <- sj454$S.Score - sj454$G2M.Score
```

```
{r}
# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
sj454.input.integration <- SCTransform(sj454, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
# prepare SJ577
# normalise the object
sj577 <- NormalizeData(sj577)

# get cell cycle scores, then regress this variable out
sj577 <- CellCycleScoring(sj577,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
sj577$CC.difference <- sj577$S.Score - sj577$G2M.Score
```

```
{r}
# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
sj577.input.integration <- SCTransform(sj577, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
# do the SCT integration 
dy.sct.list <- list(dyMono.input.integration, 
                dySpher.input.integration,
                dyOnly.dyCbo.ccn,
                muv41.input.integration, 
                sj454.input.integration,
                sj577.input.integration)
features <- SelectIntegrationFeatures(object.list = dy.sct.list, nfeatures = 3000)
dy.sct.list <- PrepSCTIntegration(object.list = dy.sct.list, anchor.features = features)
```

```
{r}
dy.sct.anchors <- FindIntegrationAnchors(object.list = dy.sct.list, normalization.method = "SCT",
    anchor.features = features)
dy.combined.sct <- IntegrateData(anchorset = dy.sct.anchors, normalization.method = "SCT")
```

```
{r}
dy.combined.sct <- RunPCA(dy.combined.sct, verbose = FALSE)
dy.combined.sct <- RunTSNE(dy.combined.sct, reduction = "pca", dims = 1:30)
```

```
{r}
# conventional integration workflow is better!
DimPlot(dy.combined.sct, reduction = "tsne", group.by = "orig.ident")
```









