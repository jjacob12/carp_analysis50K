---
title: "hovestadt_nature_2019_smartSeq2_QC_and_analysis"
author: "JJ"
date: "2023-03-02"
output: html_document
---

```{r graphical_output}
options(bitmapType='cairo-png') # this line of code needed BEFORE knitr code in chunk below
```

```{r setup, include=FALSE}
knitr::opts_chunk$set(dev = "png",
                      dpi = 300,
                      echo = TRUE,   # prints the code (if FALSE then only code output is shown)
                      cache = TRUE,
                      fig.path = "")
```

```{r libraries}
suppressPackageStartupMessages({
library(Seurat)
library(cluster)
library(glmGamPoi)
library(Matrix)
library(patchwork)
library(tidyverse)
})
```

```{r path_to_data}
raw.counts.muv41 <- read.table(file = "./hovestadt_Nature2019/GSM3905417_MUV41.txt",
                         sep = "")
```

```{r}
head(raw.counts.muv41)
```

```{r}
muv41 <- CreateSeuratObject(raw.counts.muv41,
                            min.cells = 10,
                            min.genes = 2500,
                            project = "reanalysis_hovestadt")
```

```{r}
dim(muv41)
```

```{r}
muv41 <- SCTransform(muv41, vst.flavor = "v2", verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)
```

```{r}
DimPlot(muv41, label = T, repel = T)
```

```{r fig.height=9, fig.width=12}
VlnPlot(muv41, features = c("SOX2", "ERBB4", "MEIS1", "ZIC2", "ZIC1", "TWIST1"))
```

```{r path_to_data}
raw.counts.sj454 <- read.table(file = "./hovestadt_Nature2019/GSM3905423_SJ454.txt",
                         sep = "")
```

```{r}
head(raw.counts.sj454)
```

```{r}
sj454 <- CreateSeuratObject(raw.counts.sj454,
                            min.cells = 10,
                            min.genes = 2500,
                            project = "reanalysis_hovestadt")
```

```{r}
dim(sj454)
```

```{r}
sj454 <- SCTransform(sj454, vst.flavor = "v2", verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)
```

```{r}
DimPlot(sj454, label = T, repel = T)
```

```{r}
VlnPlot(sj454, features = c("SOX2", "ERBB4", "POU3F2"))
```

```{r path_to_data}
raw.counts.sj577 <- read.table(file = "./hovestadt_Nature2019/GSM3905425_SJ577.txt",
                         sep = "")
```

```{r}
head(raw.counts.sj577)
```

```{r}
sj577 <- CreateSeuratObject(raw.counts.sj577,
                            min.cells = 10,
                            min.genes = 2500,
                            project = "reanalysis_hovestadt")
```

```{r}
dim(sj577)
```

```{r}
sj577 <- SCTransform(sj577, vst.flavor = "v2", verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunUMAP(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindNeighbors(reduction = "pca", dims = 1:30, verbose = FALSE) %>%
  FindClusters(resolution = 0.7, verbose = FALSE)
```

```{r}
DimPlot(sj577, label = T, repel = T)
```

```{r}
VlnPlot(sj577, features = c("SOX2", "ERBB4", "POU3F2"))
```


---------------------------------------------------------------------------------------------------------
***INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH DAOY-ONLY COCULTURE, DAOY-MONOLAYER AND DAOY SPHEROIDS***
conventional integration workflow shown here is better than SCTransform
****1.PREPARE MUV451****
```{r}
# load the raw counts data
raw.counts.muv41 <- read.table(file = "./hovestadt_Nature2019/GSM3905417_MUV41.txt",
                         sep = "")

# create the Seurat object. Use the Seurat min.gene default this time
muv41 <- CreateSeuratObject(raw.counts.muv41,
                            min.cells = 10,
                            min.genes = 200,
                            project = "muv41")

# identify mitochondrial genes
mito.genes <- grep(pattern = "^MT", x = rownames(x = muv41), value = TRUE)
percent.mito <- 
  Matrix::colSums(muv41[mito.genes, ])/Matrix::colSums(muv41)

# add only the mitochondrial gene percent to the metadata
muv41 <- 
  AddMetaData(object = muv41, metadata = percent.mito, col.name = "percent.mito")

# look at the metadata
head(muv41@meta.data)
```

```{r}
# get the dim of the muv41 object
dim(muv41) # 13,690 genes, 338 cells

# remove ribosomal genes
muv41 <- muv41[ ! grepl('^RP[SL]', rownames(muv41)), ]

# get the dim of the muv41 object
dim(muv41) # 13,573 genes, 338 cells

# remove mitochondrial genes 
muv41 <- muv41[ ! grepl("^MT-", rownames(muv41)), ]

# get the dim of the muv41 object
dim(muv41) # still 13,573 genes, 338 cells. The authors must have removed mitochondrial genes
```

```{r}
# find the maximum value of percent.mito to check this is also < 10%
max(muv41@meta.data$percent.mito) # maximum is only 1.7%!
```

```{r}
# normalise the object, find Variable features,
muv41 <- NormalizeData(muv41)
muv41 <- FindVariableFeatures(muv41, nfeatures = 3000)

# get cell cycle scores, then regress this variable out
muv41 <- CellCycleScoring(muv41,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
muv41 <- ScaleData(muv41, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
muv41 <- RunPCA(muv41, npcs = 50)
muv41 <- RunTSNE(muv41, dims = 1:20)
```

```{r}
saveRDS(muv41,
        file = "./outputs50K/INTEGRATE/PatientSHH-MB.MUV41.Hovestadt.InputForIntegration.conventional.rds")
```


****2. PREPARE SJ454****
```{r}
# load the raw counts data
raw.counts.sj454 <- read.table(file = "./hovestadt_Nature2019/GSM3905423_SJ454.txt",
                         sep = "")

# create the Seurat object. Use the Seurat min.gene default this time
sj454 <- CreateSeuratObject(raw.counts.sj454,
                            min.cells = 10,
                            min.genes = 200,
                            project = "sj454")

# identify mitochondrial genes
mito.genes <- grep(pattern = "^MT", x = rownames(x = sj454), value = TRUE)
percent.mito <- 
  Matrix::colSums(sj454[mito.genes, ])/Matrix::colSums(sj454)

# add only the mitochondrial gene percent to the metadata
sj454 <- 
  AddMetaData(object = sj454, metadata = percent.mito, col.name = "percent.mito")

# look at the metadata
head(sj454@meta.data)
```

```{r}
# get the dim of the sj454 object
dim(sj454) # 14,336 genes, 293 cells

# remove ribosomal genes
sj454 <- sj454[ ! grepl('^RP[SL]', rownames(sj454)), ]

# get the dim of the sj454 object
dim(sj454) # 14,218 genes, 293 cells

# remove mitochondrial genes 
sj454 <- sj454[ ! grepl("^MT-", rownames(sj454)), ]

# get the dim of the sj454 object
dim(sj454) # still 14218 genes, 293 cells. The authors must have removed mitochondrial genes
```

```{r}
# find the maximum value of percent.mito to check this is also < 10%
max(sj454@meta.data$percent.mito) # maximum is only 1.1%!
```

```{r}
# normalise the object, find Variable features,
sj454 <- NormalizeData(sj454)
sj454 <- FindVariableFeatures(sj454, nfeatures = 3000)

# get cell cycle scores, then regress this variable out
sj454 <- CellCycleScoring(sj454,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
sj454 <- ScaleData(sj454, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
sj454 <- RunPCA(sj454, npcs = 50)
sj454 <- RunTSNE(sj454, dims = 1:20)
```

```{r}
saveRDS(sj454,
        file = "./outputs50K/INTEGRATE/PatientSHH-MB.SJ454.Hovestadt.InputForIntegration.conventional.rds")
```


****3. PREPARE SJ577****
```{r}
# load the raw counts data
raw.counts.sj577 <- read.table(file = "./hovestadt_Nature2019/GSM3905425_SJ577.txt",
                         sep = "")

# create the Seurat object. Use the Seurat min.gene default this time
sj577 <- CreateSeuratObject(raw.counts.sj577,
                            min.cells = 10,
                            min.genes = 200,
                            project = "sj577")

# identify mitochondrial genes
mito.genes <- grep(pattern = "^MT", x = rownames(x = sj577), value = TRUE)
percent.mito <- 
  Matrix::colSums(sj577[mito.genes, ])/Matrix::colSums(sj577)

# add only the mitochondrial gene percent to the metadata
sj577 <- 
  AddMetaData(object = sj577, metadata = percent.mito, col.name = "percent.mito")

# look at the metadata
head(sj577@meta.data)
```

```{r}
# get the dim of the sj577 object
dim(sj577) # 14,622 genes, 493 cells

# remove ribosomal genes
sj577 <- sj577[ ! grepl('^RP[SL]', rownames(sj577)), ]

# get the dim of the sj577 object
dim(sj577) #  14,503 genes, 493 cells

# remove mitochondrial genes 
sj577 <- sj577[ ! grepl("^MT-", rownames(sj577)), ]

# get the dim of the sj577 object
dim(sj577) # still 14,503 genes, 493 cells. The authors must have removed mitochondrial genes
```

```{r}
# find the maximum value of percent.mito to check this is also < 10%
max(sj577@meta.data$percent.mito) # maximum is only 1.3%!
```

```{r}
# normalise the object, find Variable features,
sj577 <- NormalizeData(sj577)
sj577 <- FindVariableFeatures(sj577, nfeatures = 3000)

# get cell cycle scores, then regress this variable out
sj577 <- CellCycleScoring(sj577,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
sj577 <- ScaleData(sj577, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
sj577 <- RunPCA(sj577, npcs = 50)
sj577 <- RunTSNE(sj577, dims = 1:20)
```

```{r}
saveRDS(sj577,
        file = "./outputs50K/INTEGRATE/PatientSHH-MB.SJ577.Hovestadt.InputForIntegration.conventional.rds")
```


****4. PREPARE DAOY-ONLY CELLS IN DAOY COCULTURE***
```{r}
# load the object
dyOnly.dyCbo <- readRDS("outputs50K/DAOY-CBO/DAOYOnlyCells.SubsetDAOYCboSample.Annotated.Rescaled.SCT.NoRiboNoMito.CCdiffRegressed.rds")

# get the cellIDs of dyOnly.dyCbo and store the cell IDs as a vector
dyOnly.cellID <- WhichCells(dyOnly.dyCbo)

# check the cell names are correctly formatted
head(WhichCells(dyOnly.dyCbo))

# use the above cellIDs to extract the DAOY cells from DAOY-CBO coculture
```

```{r}
# compare the cell names with dyCbo - there is a prefix
dyCbo <- readRDS("outputs50K/DAOY-CBO/daoyCbo.seurat.filtCellsGenesNoRiboNoMito.rds")
head(WhichCells(dyCbo))
```

```{r}
# pull out the dyOnly cells (all three clusters) in coculture which have not been through SCT and clustering
dyOnly <- subset(dyCbo, cells = dyOnly.cellID)
dim(dyOnly) # DAOY cells = 265 cells
```

```{r}
# change the formatting of the cell names: remove the prefixes from the vector cell names 
# and save as a new object of cell IDs
dyOnly.cellID.corrected <- gsub('dyCbo.data-', '', dyOnly.cellID)
head(dyOnly.cellID.corrected) # the prefixes have been removed
```

```{r}
# rename the cell IDs with the corrected cell names
# the object dyOnly is the one to use going forwards
dyOnly <- RenameCells(dyOnly, new.names = dyOnly.cellID.corrected)
head(WhichCells(dyOnly))
```

```{r}
# normalise data, find variable features, then do cell cycle scoring
dyOnly <- NormalizeData(dyOnly)
dyOnly <- FindVariableFeatures(dyOnly, nfeatures = 3000)
dyOnly <- CellCycleScoring(dyOnly,
                s.features = cc.genes$s.genes,
                g2m.features = cc.genes$g2m.genes)

# scale the data
dyOnly <- ScaleData(dyOnly, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
dyOnly <- RunPCA(dyOnly, npcs = 50)
dyOnly <- RunTSNE(dyOnly, dims = 1:20)
```

```{r}
saveRDS(dyOnly,
        file = "./outputs50K/INTEGRATE/DaoyOnlyCocult.InputForConventionalIntegration.Hovestadt.rds")
```

****5. PREPARE DAOY MONOLAYER****
```{r}
# load the DAOY-MONOLAYER
dyMono <- readRDS("outputs50K/DAOY_2D/filt.RiboMitoCellsGenes.seurat.DaoyMonolayer.rds")

# normalise data, find variable features, then do cell cycle scoring
dyMono <- NormalizeData(dyMono)
dyMono <- FindVariableFeatures(dyMono, nfeatures = 3000)
dyMono <- CellCycleScoring(dyMono,
                s.features = cc.genes$s.genes,
                g2m.features = cc.genes$g2m.genes)

# scale the data, cluster the cells
dyMono <- ScaleData(dyMono, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
dyMono <- RunPCA(dyMono, npcs = 50)
dyMono <- RunTSNE(dyMono, dims = 1:20)
```

```{r}
saveRDS(dyMono,
        file = "./outputs50K/INTEGRATE/DaoyMono.InputForConventionalIntegration.Hovestadt.rds")
```


****6. PREPARE DAOY-SPHEROID****
```{r}
# load the DAOY-SPHEROID dataset
dySpher <- readRDS("outputs50K/DAOY_SPHER/filt.RiboMitoCellsGenes.seurat.DAOYspher.rds")

# normalise data, find variable features, then do cell cycle scoring
dySpher <- NormalizeData(dySpher)
dySpher <- FindVariableFeatures(dySpher, nfeatures = 3000)
dySpher <- CellCycleScoring(dySpher,
                s.features = cc.genes$s.genes,
                g2m.features = cc.genes$g2m.genes)

# scale the data, cluster the cells
dySpher <- ScaleData(dySpher, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
dySpher <- RunPCA(dySpher, npcs = 50)
dySpher <- RunTSNE(dySpher, dims = 1:20)
```

```{r}
saveRDS(dySpher,
        file = "./outputs50K/INTEGRATE/DaoySpher.InputForConventionalIntegration.Hovestadt.rds")
```

THIS IS THE LIST OF FILES FOR INTEGRATION
```{r}
# merge the datasets - shows the SHH patient tumours are quite separated, and suggests batch effects
dyMono <- readRDS("outputs50K/INTEGRATE/DaoyMono.InputForConventionalIntegration.Hovestadt.rds")
dySpher <- readRDS("outputs50K/INTEGRATE/DaoySpher.InputForConventionalIntegration.Hovestadt.rds")
dyOnly <- readRDS("outputs50K/INTEGRATE/DaoyOnlyCocult.InputForConventionalIntegration.Hovestadt.rds")
muv41 <- readRDS("outputs50K/INTEGRATE/PatientSHH-MB.MUV41.Hovestadt.InputForIntegration.conventional.rds")
sj454 <- readRDS("outputs50K/INTEGRATE/PatientSHH-MB.SJ454.Hovestadt.InputForIntegration.conventional.rds")
sj577 <- readRDS("outputs50K/INTEGRATE/PatientSHH-MB.SJ577.Hovestadt.InputForIntegration.conventional.rds")

shhMb1 <- merge(dyMono,
      y = c(dySpher, dyOnly, muv41, sj454, sj577)) %>% 
  FindVariableFeatures(nfeatures = 3000) %>% 
  ScaleData() %>% 
  RunPCA(npcs = 50) %>% 
  RunTSNE(dims = 1:20)
```

```{r}
saveRDS(shhMb1,
        file = "./outputs50K/INTEGRATE/Hovestadt.PatientSHHMB.DAOYmono.spher.cocult.Merge.rds")
```

```{r}
# also save above object in the folder 'outputs50K/Hovestadt_outputs/'
saveRDS(shhMb1,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.Hovestadt.PatientSHHMB_n=3.DAOYmono.spher.cocult.MERGE.rds")
```


```{r}
shhMb1 <- readRDS("outputs50K/INTEGRATE/Hovestadt.PatientSHHMB.DAOYmono.spher.cocult.Merge.rds")
```


```{r DimplotTSNEhovestadtSHHMBdaoyMerge6samples, fig.height=6, fig.width=10}
DimPlot(shhMb1, group.by = "orig.ident", pt.size = 2) +
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```


Try integrating the data instead of a simple merge
```{r}
seurat.list <- list(dyMono, dySpher, dyOnly, muv41, sj454, sj577)
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb1.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb1.combined <- IntegrateData(anchorset = shhMb1.anchors)
```

```{r}
DefaultAssay(shhMb1.combined) <- "integrated"
shhMb1.combined <- ScaleData(shhMb1.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
saveRDS(shhMb1.combined,
        file = "./outputs50K/INTEGRATE/Hovestadt.SHH-MBpatients.DAOYmono.spher.cocult.clustered.conventionalIntegration.rds")
```

```{r}
# also save the shhMb1.combined object to outputs50K/Hovestadt_outputs/
saveRDS(shhMb1.combined,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.spher.cocult.clustered.conventionalIntegration.rds")
```

```{r DimplotTSNEHovestadtPatientSHHMBDAOYintegrationConventional, fig.height=6, fig.width=10}
# load the above object
shhMb1.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.spher.cocult.clustered.conventionalIntegration.rds")

DimPlot(shhMb1.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

Get the Cell mixing score:
```{r}
shhMb1.combined.mm <- MixingMetric(object = shhMb1.combined,  # MixingMetric is a numeric vector
             grouping.var = "orig.ident",
             reduction = "tsne",
             dims = 1:2,
             k = 5,
             max.k = 300,
             eps = 0,
             verbose = TRUE)
```

```{r}
saveRDS(shhMb1.combined.mm,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.combined.mm_MixingMetricScores.rds")
```


INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH DAOY-ONLY COCULTURE, AND DAOY SPHEROIDS (OMITTING DAOY MONOLAYER)
This is to see what the tSNE looks like without the DAOY-monolayer
```{r}
seurat.list <- list(dySpher, dyOnly, muv41, sj454, sj577)
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb1.1.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb1.1.combined <- IntegrateData(anchorset = shhMb1.1.anchors)
```

```{r}
DefaultAssay(shhMb1.1.combined) <- "integrated"
shhMb1.1.combined <- ScaleData(shhMb1.1.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
# save shhMb1.1.combined
saveRDS(shhMb1.1.combined,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.1.combined.Hovestadt.SHH-MBpatients_n=3.DAOYspher.cocult.clustered.conventionalIntegration.rds")
```

On visual inspection it looks like there is some clumping/clustering of DAOY-SPHER sample
```{r DimplotTSNEHovestadtPatientSHHMBDAOYcocultSpherIntegrationConventional, fig.height=6, fig.width=10}
# load the above object
shhMb1.1.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.1.combined.Hovestadt.SHH-MBpatients_n=3.DAOYspher.cocult.clustered.conventionalIntegration.rds")

DimPlot(shhMb1.1.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```



From the paper by Stuart et al, Cell 2019, they used 3 metrics to judge how well cells were mixed after integration. 1. Mixing score:
```{r}
shhMb1.1.combined.mm <- MixingMetric(object = shhMb1.1.combined,  # MixingMetric is a vector
             grouping.var = "orig.ident",
             reduction = "tsne",
             dims = 1:2,
             k = 5,
             max.k = 300,
             eps = 0,
             verbose = TRUE)
```

```{r}
# save shhMb1.1.combined.mm
saveRDS(shhMb1.1.combined.mm,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.1.combined.mm_MixingMetricScores.rds")
```


INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH DAOY-ONLY COCULTURE (OMITTING DAOY MONOLAYER AND DAOY-SPHEROID)
```{r}
seurat.list <- list(dyOnly, muv41, sj454, sj577)
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb1.2.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb1.2.combined <- IntegrateData(anchorset = shhMb1.2.anchors)
```

```{r}
DefaultAssay(shhMb1.2.combined) <- "integrated"
shhMb1.2.combined <- ScaleData(shhMb1.2.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
# save shhMb1.2.combined
saveRDS(shhMb1.2.combined,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.2.combined.Hovestadt.SHH-MBpatients_n=3.DAOYcocult.clustered.conventionalIntegration.rds")
```

```{r DimplotTSNEHovestadtPatientSHHMBDAOYcocultIntegrationConventional, fig.height=6, fig.width=10}
# load the object
shhMb1.2.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.2.combined.Hovestadt.SHH-MBpatients_n=3.DAOYcocult.clustered.conventionalIntegration.rds")

DimPlot(shhMb1.2.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

```{r}
shhMb1.2.combined.mm <- MixingMetric(object = shhMb1.2.combined,  # MixingMetric is a vector
             grouping.var = "orig.ident",
             reduction = "tsne",
             dims = 1:2,
             k = 5,
             max.k = 300,
             eps = 0,
             verbose = TRUE)
```

```{r}
# save shhMb1.2.combined.mm
saveRDS(shhMb1.2.combined.mm,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.2.combined.mm_MixingMetricScores.rds")
```


INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH DAOY-SPHEROID (OMITTING monolayer and DAOY-only coculture)
```{r}
seurat.list <- list(dySpher, muv41, sj454, sj577)
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb1.3.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb1.3.combined <- IntegrateData(anchorset = shhMb1.3.anchors)
```

```{r}
DefaultAssay(shhMb1.3.combined) <- "integrated"
shhMb1.3.combined <- ScaleData(shhMb1.3.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
# save shhMb1.3.combined
saveRDS(shhMb1.3.combined,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.3.combined.Hovestadt.SHH-MBpatients_n=3.DAOYspher.clustered.conventionalIntegration.rds")
```

```{r DimplotTSNEHovestadtPatientSHHMBDAOYspherIntegrationConventional, fig.height=6, fig.width=10}
# load the shhMb1.3.combined object
shhMb1.3.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.3.combined.Hovestadt.SHH-MBpatients_n=3.DAOYspher.clustered.conventionalIntegration.rds")

DimPlot(shhMb1.3.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

```{r}
shhMb1.3.combined.mm <- MixingMetric(object = shhMb1.3.combined,  # MixingMetric is a vector
             grouping.var = "orig.ident",
             reduction = "tsne",
             dims = 1:2,
             k = 5,
             max.k = 300,
             eps = 0,
             verbose = TRUE)
```

```{r}
# save shhMb1.3.combined.mm
saveRDS(shhMb1.3.combined.mm,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.3.combined.mm_MixingMetricScores.rds")
```

INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES AND DAOY-MONOLAYER
```{r}
seurat.list <- list(dyMono, muv41, sj454, sj577)
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb1.4.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb1.4.combined <- IntegrateData(anchorset = shhMb1.4.anchors)
```

```{r}
DefaultAssay(shhMb1.4.combined) <- "integrated"
shhMb1.4.combined <- ScaleData(shhMb1.4.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
# save shhMb1.4.combined
saveRDS(shhMb1.4.combined,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.4.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.clustered.conventionalIntegration.rds")
```

```{r DimplotTSNEHovestadtPatientSHHMBDAOYmonoIntegrationConventional, fig.height=6, fig.width=10}
# load the shhMb1.4.combined object
shhMb1.4.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.4.combined.Hovestadt.SHH-MBpatients_n=3.DAOYmono.clustered.conventionalIntegration.rds")

DimPlot(shhMb1.4.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

```{r}
shhMb1.4.combined.mm <- MixingMetric(object = shhMb1.4.combined,  # MixingMetric is a vector
             grouping.var = "orig.ident",
             reduction = "tsne",
             dims = 1:2,
             k = 5,
             max.k = 300,
             eps = 0,
             verbose = TRUE)
```

```{r}
# save shhMb1.4.combined.mm
saveRDS(shhMb1.4.combined.mm,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.4.combined.mm_MixingMetricScores.rds")
```


INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES ONLY (NO DAOY SAMPLES)
```{r}
seurat.list <- list(muv41, sj454, sj577) # Patient SHH-MB tumour samples only
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb1.5.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb1.5.combined <- IntegrateData(anchorset = shhMb1.5.anchors)
```

```{r}
DefaultAssay(shhMb1.5.combined) <- "integrated"
shhMb1.5.combined <- ScaleData(shhMb1.5.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
# save shhMb1.5.combined
saveRDS(shhMb1.5.combined,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.5.combined.Hovestadt.SHH-MBpatients_n=3.NoDAOY.conventionalIntegration.rds")
```

```{r DimplotTSNEHovestadtPatientSHHMBonlyIntegrationConventional, fig.height=6, fig.width=10}
# load shhMb1.5.combined
shhMb1.5.combined <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.5.combined.Hovestadt.SHH-MBpatients_n=3.NoDAOY.conventionalIntegration.rds")

DimPlot(shhMb1.5.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

```{r}
shhMb1.5.combined.mm <- MixingMetric(object = shhMb1.5.combined,  # MixingMetric is a vector
             grouping.var = "orig.ident",
             reduction = "tsne",
             dims = 1:2,
             k = 5,
             max.k = 300,
             eps = 0,
             verbose = TRUE)
```

```{r}
# save shhMb1.5.combined.mm
saveRDS(shhMb1.5.combined.mm,
        file = "./outputs50K/Hovestadt_outputs/object_shhMb1.5.combined.mm_MixingMetricScores.rds")
```


```{r}
# load all the Mixing Metric score objects
shhMb1.combined.mm <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.combined.mm_MixingMetricScores.rds")
shhMb1.1.combined.mm <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.1.combined.mm_MixingMetricScores.rds")
shhMb1.2.combined.mm <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.2.combined.mm_MixingMetricScores.rds")
shhMb1.3.combined.mm <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.3.combined.mm_MixingMetricScores.rds")
shhMb1.4.combined.mm <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.4.combined.mm_MixingMetricScores.rds")
shhMb1.5.combined.mm <- readRDS("outputs50K/Hovestadt_outputs/object_shhMb1.5.combined.mm_MixingMetricScores.rds")
```


Make a ggplot violin plot of all the MixingMetric scores for the different integrations
```{r}
# check the lengths of each vector to find the longest - longest vector has 4671 values
length(shhMb1.combined.mm)   # mono + cocult + spher + patient MB
length(shhMb1.1.combined.mm) # cocult + spher + patient MB
length(shhMb1.2.combined.mm) # cocult + patient MB
length(shhMb1.3.combined.mm) # spher + patient MB
length(shhMb1.4.combined.mm) # monolayer + patient MB
length(shhMb1.5.combined.mm) # patient MB
```

```{r}
# make all the vectors the same length by adding NA values
shhMb1.combined.mm.na <- c(shhMb1.combined.mm)
shhMb1.1.combined.mm.na <- c(shhMb1.1.combined.mm, rep(NA, 2633)) # add 2633 NA values to make this
                                                                  # vector the same length as
                                                                  # shhMb1.combined.mm
shhMb1.2.combined.mm.na <- c(shhMb1.2.combined.mm, rep(NA, 3282))
shhMb1.3.combined.mm.na <- c(shhMb1.3.combined.mm, rep(NA, 2898))
shhMb1.4.combined.mm.na <- c(shhMb1.4.combined.mm, rep(NA, 914))
shhMb1.5.combined.mm.na <- c(shhMb1.5.combined.mm, rep(NA, 3547))

```

```{r}
summary(shhMb1.combined.mm) # mono + cocult + spher + patient MB
summary(shhMb1.1.combined.mm.na) # cocult + spher + patient MB
summary(shhMb1.2.combined.mm.na) # cocult + patient MB
summary(shhMb1.3.combined.mm.na) # spher + patient MB
summary(shhMb1.4.combined.mm.na) # monolayer + patient MB
summary(shhMb1.5.combined.mm.na) # patient MB

#so the order from highest to lowest median is:
# shhMb1.4.combined.mm.na, median=139, mono_patientMB
# shhMb1.combined.mm, median=115.5, mono_spher_cocult_patientMB
# shhMb1.1.combined.mm.na, median=33.00, spher_cocult_patientMB
# shhMb1.3.combined.mm.na, median=24.50, spher_patientMB
# shhMb1.2.combined.mm.na, median=20.50, cocult_patientMB
# shhMb1.5.combined.mm.na, median=15, patientMB
```

```{r}
# create a dataframe of the MixingMetric scores for all integrations
daoy.patientMB.df <- data.frame(mono_patientMB = shhMb1.4.combined.mm.na,
                                mono_spher_cocult_patientMB = shhMb1.combined.mm,
                                spher_cocult_patientMB = shhMb1.1.combined.mm.na,
                                cocult_patientMB = shhMb1.2.combined.mm.na,
                                spher_patientMB = shhMb1.3.combined.mm.na,
                                patientMB = shhMb1.5.combined.mm.na)
```

```{r}
# save the above df
saveRDS(daoy.patientMB.df,
        file = "./outputs50K/Hovestadt_outputs/object_daoy.patientMB.df.Hovestadt.DataFrame.MixingMetricScores.shhMb1to5combined.mm.NA.rds")
```


```{r}
# load the above df
daoy.patientMB.df <- readRDS("outputs50K/Hovestadt_outputs/object_daoy.patientMB.df.Hovestadt.DataFrame.MixingMetricScores.shhMb1to5combined.mm.NA.rds")

# reformat the df to long format for ggplot
daoy.patientMB.df.long <- pivot_longer(daoy.patientMB.df,
                                       cols = c(mono_patientMB,
                                                mono_spher_cocult_patientMB,
                                                spher_cocult_patientMB,
                                                cocult_patientMB,
                                                spher_patientMB,
                                                patientMB),
                                       names_to = "groups.fct",
                                       values_to = "mixing_metric")
daoy.patientMB.df.long$groups.fct <- factor(daoy.patientMB.df.long$groups.fct)
```

```{r}
# prepare the data so it is plotted in descending order of median values in 'mixing_metric' col
levels.order <- c("mono_patientMB", "mono_spher_cocult_patientMB", "spher_cocult_patientMB",
                  "spher_patientMB", "cocult_patientMB", "patientMB")
daoy.patientMB.df.long$groups.fct <- factor(daoy.patientMB.df.long$groups.fct,
                                            levels = levels.order)
```


*****These two graphs support my hypothesis that SHH-MB cell lines grown in coculture with cerebellar organoids resemble patient SHH-MB more closely than tumour spheroids or monolayers*****
```{r}
# violin plot of the MixingMetric scores for all integrations
ggplot(daoy.patientMB.df.long, aes(x = groups.fct, y = mixing_metric)) +
  geom_violin(scale = "width", fill = "light blue", colour = "light blue") +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```


```{r}
# box and whisker plot of mixing metric scores in descending order of median values
ggplot(daoy.patientMB.df.long, aes(x = groups.fct, y = mixing_metric)) +
  geom_boxplot(fill = "light blue") +
  # geom_dotplot(binaxis = "y", stackdir = "center", dotsize = 0.5, alpha = 0.2) +
  theme_classic() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))
```


----------------------------------------------------------------------------------------------------------
***INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH DAOY SPHEROID USING SILHOUETTE ANALYSIS***




------------------------------------------------------------------------------------------------------------
***INTEGRATED ANALYSIS OF PATIENT SHH-MB SAMPLES WITH ONS76-ONLY COCULTURE, ONS76 SPHEROIDS and ONS76-MONOLAYER***
****1. PREPARE ONS76 MONOLAYER****
```{r}
# load the ONS76-MONOLAYER
o76mono <- readRDS("outputs50K/ONS76_2D/filt.RiboMitoCellsGenes.seurat.ons76monolayer.rds")

# normalise data, find variable features, then do cell cycle scoring
o76mono <- NormalizeData(o76mono)
o76mono <- FindVariableFeatures(o76mono, nfeatures = 3000)
o76mono <- CellCycleScoring(o76mono,
                s.features = cc.genes$s.genes,
                g2m.features = cc.genes$g2m.genes)

# scale the data, cluster the cells
o76mono <- ScaleData(o76mono, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
o76mono <- RunPCA(o76mono, npcs = 50)
o76mono <- RunTSNE(o76mono, dims = 1:20)
```

```{r}
saveRDS(o76mono,
        file = "./outputs50K/INTEGRATE/ONS76mono.InputForConventionalIntegration.Hovestadt.rds")
```

****2. PREPARE ONS76-SPHEROID****
```{r}
# load the DAOY-SPHEROID dataset
o76spher <- readRDS("outputs50K/ONS76_SPHER/filt.RiboMitoCellsGenes.seurat.ons76spheroid.rds")

# normalise data, find variable features, then do cell cycle scoring
o76spher <- NormalizeData(o76spher)
o76spher <- FindVariableFeatures(o76spher, nfeatures = 3000)
o76spher <- CellCycleScoring(o76spher,
                s.features = cc.genes$s.genes,
                g2m.features = cc.genes$g2m.genes)

# scale the data, cluster the cells
o76spher <- ScaleData(o76spher, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
o76spher <- RunPCA(o76spher, npcs = 50)
o76spher <- RunTSNE(o76spher, dims = 1:20)
```

```{r}
saveRDS(o76spher,
        file = "./outputs50K/INTEGRATE/ONS76spheroid.InputForConventionalIntegration.Hovestadt.rds")
```

****3. PREPARE ONS76-ONLY CELLS IN ONS76 COCULTURE***
```{r}
# load the object
o76only.o76cbo <- readRDS("outputs50K/ONS76-CBO/ONS76OnlyCells.SubsetONS76CboSample.Annotated.Rescaled.SCT.NoRiboNoMito.CCdiffRegressed.rds")

# get the cellIDs of dyOnly.dyCbo and store the cell IDs as a vector
o76only.cellID <- WhichCells(o76only.o76cbo)

# check the cell names are correctly formatted
head(WhichCells(o76only.o76cbo))

# use the above cellIDs to extract the DAOY cells from DAOY-CBO coculture
```

```{r}
# compare the cell names with o76cbo - there is a prefix
o76cbo <- readRDS("outputs50K/ONS76-CBO/ons76cbo.seurat.filtCellsGenesNoRiboNoMito.rds")
head(WhichCells(o76cbo))
```

```{r}
# pull out the o76only cells (both clusters) in coculture which have not been through SCT and clustering
o76only <- subset(o76cbo, cells = o76only.cellID)
dim(o76only) # ONS76 cells = 361 cells
```

```{r}
# change the formatting of the cell names: remove the prefixes from the vector cell names 
# and save as a new object of cell IDs
o76only.cellID.corrected <- gsub('o76cbo.data-', '', o76only.cellID)
head(o76only.cellID.corrected) # the prefixes have been removed
```

```{r}
# rename the cell IDs with the corrected cell names
# the object o76only is the one to use going forwards
o76only <- RenameCells(o76only, new.names = o76only.cellID.corrected)
head(WhichCells(o76only))
```

```{r}
# normalise data, find variable features, then do cell cycle scoring
o76only <- NormalizeData(o76only)
o76only <- FindVariableFeatures(o76only, nfeatures = 3000)
o76only <- CellCycleScoring(o76only,
                s.features = cc.genes$s.genes,
                g2m.features = cc.genes$g2m.genes)

# scale the data
o76only <- ScaleData(o76only, vars.to.regress = c("S.Score", "G2M.Score"))

# run PCA and tSNE
o76only <- RunPCA(o76only, npcs = 50)
o76only <- RunTSNE(o76only, dims = 1:20)
```

```{r}
saveRDS(o76only,
        file = "./outputs50K/INTEGRATE/ONS76onlyCocult.InputForConventionalIntegration.Hovestadt.rds")
```

```{r}
# merge the datasets - shows the SHH patient tumours are quite separated, and suggests batch effects
o76mono <- readRDS("outputs50K/INTEGRATE/ONS76mono.InputForConventionalIntegration.Hovestadt.rds")
o76spher <- readRDS("outputs50K/INTEGRATE/ONS76spheroid.InputForConventionalIntegration.Hovestadt.rds")
o76only <- readRDS("outputs50K/INTEGRATE/ONS76onlyCocult.InputForConventionalIntegration.Hovestadt.rds")
muv41 <- readRDS("outputs50K/INTEGRATE/PatientSHH-MB.MUV41.Hovestadt.InputForIntegration.conventional.rds")
sj454 <- readRDS("outputs50K/INTEGRATE/PatientSHH-MB.SJ454.Hovestadt.InputForIntegration.conventional.rds")
sj577 <- readRDS("outputs50K/INTEGRATE/PatientSHH-MB.SJ577.Hovestadt.InputForIntegration.conventional.rds")

shhMb2 <- merge(o76mono,
      y = c(o76spher, o76only, muv41, sj454, sj577)) %>% 
  FindVariableFeatures(nfeatures = 3000) %>% 
  ScaleData() %>% 
  RunPCA(npcs = 50) %>% 
  RunTSNE(dims = 1:20)
```

```{r}
saveRDS(shhMb2,
        file = "./outputs50K/INTEGRATE/Hovestadt.PatientSHHMB.ONS76mono.spher.cocult.Merge.rds")
```

```{r}
shhMb2 <- readRDS("outputs50K/INTEGRATE/Hovestadt.PatientSHHMB.ONS76mono.spher.cocult.Merge.rds")
```

```{r DimplotTSNEhovestadtSHHMBons76Merge6samples, fig.height=6, fig.width=10}
# as with DAOY cells, there is a prominent batch effect, with samples clustering by batch
DimPlot(shhMb2, group.by = "orig.ident", pt.size = 2) +
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

```{r}
# integrate the samples
seurat.list <- list(o76mono, o76spher, o76only, muv41, sj454, sj577)
features <- SelectIntegrationFeatures(object.list = seurat.list)
shhMb2.anchors <- FindIntegrationAnchors(object.list = seurat.list, anchor.features = features)
shhMb2.combined <- IntegrateData(anchorset = shhMb2.anchors)
```

```{r}
DefaultAssay(shhMb2.combined) <- "integrated"
shhMb2.combined <- ScaleData(shhMb2.combined, verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE) %>% 
  RunTSNE(reduction = "pca", dims = 1:30) %>% 
  FindNeighbors(reduction = "pca", dims = 1:30) %>% 
  FindClusters(resolution = 0.5)
```

```{r}
saveRDS(shhMb2.combined,
        file = "./outputs50K/INTEGRATE/Hovestadt.SHH-MBpatients.ONS76mono.spher.cocult.clustered.conventionalIntegration.rds")
```

```{r}
shhMb2.combined <- readRDS("outputs50K/INTEGRATE/Hovestadt.SHH-MBpatients.ONS76mono.spher.cocult.clustered.conventionalIntegration.rds")
```

This shows that unlike with DAOY cells, the ONS76-spheroid sample is more transcriptionally distinct than all the other samples, even the ONS76-monolayer. What is clear is that ONS76 cells in coculture are well integrated with the patient SHH-MB's.
```{r DimplotTSNEHovestadtPatientSHHMBONS76integrationConventional, fig.height=6, fig.width=10}
DimPlot(shhMb2.combined, reduction = "tsne", group.by = "orig.ident", pt.size = 2) +
 # guides(color = guide_legend(override.aes = list(size=12), ncol=1) ) - this is optional
  theme(legend.text=element_text(size=20)) +
  labs(title = "")
```

















--------------------------------------------------------------------------------------------------------
CODE THAT WAS NOT VERY USEFUL BUT RETAINED FOR FUTURE USE

SCTransform integration did not work so well even with cell cycle regression and using the full DAOY-monolayer (DAOY-rep) or using a donsampled DAOY monolayer 

Try SCTransform as the spheroid and the daoy-only coculture overlap a lot

```
{r}
# trial of SCTransform
dyMono <- readRDS("outputs50K/DAOY_2D/filt.RiboMitoCellsGenes.seurat.DaoyMonolayer.rds")
# normalise data
dyMono <- NormalizeData(dyMono)
# calculate CC difference
dyMono <- CellCycleScoring(dyMono,
                g2m.features = cc.genes$g2m.genes,
                s.features = cc.genes$s.genes)
dyMono$CC.difference <- dyMono$S.Score - dyMono$G2M.Score
```

```
{r}

# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
dyMono.input.integration <- SCTransform(dyMono, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
dySpher.input.integration <- 
  readRDS("outputs50K/DAOY_SPHER/DAOYspher.inputIntegration.SCTransformed.CCdiffRegressed.PCA.unclustered.rds")
```

```
{r}
dyOnly.dyCbo <- 
  readRDS("outputs50K/DAOY-CBO/DAOYOnlyCells.SubsetDAOYCboSample.Annotated.Rescaled.SCT.NoRiboNoMito.CCdiffRegressed.rds")
```

As can be seen from the below, the dyOnly.dyCbo object has a prefix before the cell ID. This must be removed before proceeding
```
{r}
head(WhichCells(dyOnly.dyCbo))
```

```
{r}
# store the above cell IDs as a vector
dyOnly.cellID <- WhichCells(dyOnly.dyCbo)
```

```
{r}
# remove the prefixes from the vector cell names and save as a new object of cell IDs
dyOnly.cellID.corrected <- gsub('dyCbo.data-', '', dyOnly.cellID)
head(dyOnly.cellID.corrected) # the prefixes have been removed
```

```
{r}
# rename the cell IDs with the corrected cell names (.ccn = corrected cell names)
# the object dyOnly.dyCbo.ccn is the one to use going forwards
dyOnly.dyCbo.ccn <- RenameCells(dyOnly.dyCbo, new.names = dyOnly.cellID.corrected)
head(WhichCells(dyOnly.dyCbo.ccn))
```

```
{r}
# prepare MUV41
# normalise the object
muv41 <- NormalizeData(muv41)

# get cell cycle scores, then regress this variable out
muv41 <- CellCycleScoring(muv41,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes)
muv41$CC.difference <- muv41$S.Score - muv41$G2M.Score
```

```
{r}
# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
muv41.input.integration <- SCTransform(muv41, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
# prepare SJ454
# normalise the object
sj454 <- NormalizeData(sj454)

# get cell cycle scores, then regress this variable out
sj454 <- CellCycleScoring(sj454,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
sj454$CC.difference <- sj454$S.Score - sj454$G2M.Score
```

```
{r}
# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
sj454.input.integration <- SCTransform(sj454, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
# prepare SJ577
# normalise the object
sj577 <- NormalizeData(sj577)

# get cell cycle scores, then regress this variable out
sj577 <- CellCycleScoring(sj577,
                          s.features = cc.genes$s.genes,
                          g2m.features = cc.genes$g2m.genes,
                          set.ident = TRUE)
sj577$CC.difference <- sj577$S.Score - sj577$G2M.Score
```

```
{r}
# this object is input for integration - already SCTransformed, CCdiff regressed, and RunPCA()
sj577.input.integration <- SCTransform(sj577, 
                   vars.to.regress = "CC.difference",
                   method = "glmGamPoi",
                   vst.flavor = "v2",
                   verbose = FALSE) %>% 
  RunPCA(npcs = 30, verbose = FALSE)
```

```
{r}
# do the SCT integration 
dy.sct.list <- list(dyMono.input.integration, 
                dySpher.input.integration,
                dyOnly.dyCbo.ccn,
                muv41.input.integration, 
                sj454.input.integration,
                sj577.input.integration)
features <- SelectIntegrationFeatures(object.list = dy.sct.list, nfeatures = 3000)
dy.sct.list <- PrepSCTIntegration(object.list = dy.sct.list, anchor.features = features)
```

```
{r}
dy.sct.anchors <- FindIntegrationAnchors(object.list = dy.sct.list, normalization.method = "SCT",
    anchor.features = features)
dy.combined.sct <- IntegrateData(anchorset = dy.sct.anchors, normalization.method = "SCT")
```

```
{r}
dy.combined.sct <- RunPCA(dy.combined.sct, verbose = FALSE)
dy.combined.sct <- RunTSNE(dy.combined.sct, reduction = "pca", dims = 1:30)
```

```
{r}
# conventional integration workflow is better!
DimPlot(dy.combined.sct, reduction = "tsne", group.by = "orig.ident")
```









